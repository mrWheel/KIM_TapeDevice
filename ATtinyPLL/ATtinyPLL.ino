/*
***************************************************************************  
**  Program  : ATtinyPLL
**  Copyright (c) 2017-2021 Willem Aandewiel
**
**  TERMS OF USE: MIT License. See bottom of file.                                                            
***************************************************************************  
**  
** Micro-KIM Tape Device, ATTiny85 / ESP8266
**
** The original KIM-1 uses a PLL and a comparator to implement the receive
** path of the cassette interface. These two parts have been replaced by
** this implementation which runs on a ATTiny85 microcontroller.
**
** The KIM-1 cassette format encodes each bit using two tones:
**  1) A high-frequency tone of 3623.188 Hz 
**  2) A low-frequency tone of 2415.459 Hz
** 
** Each bit is broken up into three periods, each of which is 2.484 ms long,
** during which either the low frequency or the high frequency tone is played.
**
** Every bit starts with some high frequency pulses and ends with some low 
** frequency pulses. 
** The moment of the transition between the high- and low-frequency determines
** whether it is a '1' or a '0' bit. 
**
**      <-2482ms-> <-2484ms-> <-2484ms->
**      HHHHHHHHH  HHHHHHHHH    LLLLLL              => is a '0'
**      HHHHHHHHH    LLLLLL     LLLLLL              => is a '1'
**     
**      <---- duration ------>
**      <-duration-->
**
** The KIM-1 cassette interface uses a PLL tuned to distinguish between the
** high and low frequency tone. The output of this PLL is then fed into a
** comparator to generate a logic '1' whenever the high frequency is detected,
** and a logic '0' whenever the low frequency is detected. This logic signal
** is analyzed by the KIM-1 to reconstruct the bit-stream stored on the cassette
** tape. Each bit begins with a low-high transition, and the bit value can be
** determine by the timing of the falling edge generated by the high-frequency
** to low-frequency transition within each bit.
** 
** The job of the ATTiny85 is to perform the same function of the original PLL 
** and comparator: analyze the input signal, and generate a logic '1' output 
** whenever the high frequency is detected, and a logic '0' output whenever the 
** low frequency is detected. 
** It does this by starting a timer the moment the High freguency is detected
** and stop the timer the moment the Low frequency is detected. If the duration 
** between the starting and ending is > 3.726 milliseconds, than make the 
** output-pin LOW. If it is < 3.726 millis seconds, than make the output-pin
** HIGH.
** 
** The output-pin is connected to the TAPE_IN pin of the ESP8266 which will
** combine the bits into bytes for further processing.
**   
***************************************************************************  
*/

#include "Debug.h"

#define _BV(bit)            (1 << (bit))
#define SET(a,b)            ((a) |= _BV(b))
#define CLEAR(a,b)          ((a) &= ~_BV(b))

#define WAIT4BIT  1000
#define PLLTIME   5000

// ======================================================
// determine CPY type by verbose compile (preferences)
// parm -mmcu=atxys ==> transaltes into "__AVR_ATxys__"
// Also the -D flag can have/has someting to do with it..
// https://stackoverflow.com/questions/13853109/determine-board-type-of-arduino
// ======================================================
#if defined(__AVR_ATmega328P__)
    // --- PORT and BIT for UNO
    #define _PORTIN         PIND        // Port D
    #define _ARDUINO_IN     3           // ArduinoPin 3
    //                        76543210
    #define _BIT_IN         0B00001000
    #define _PORTOUT        PORTD       // Port D
    #define _ARDUINO_OUT    7           // ArduinoPin 7
    //                        76543210
    #define _BIT_OUT        0B10000000
    #define _MID  320
//
#elif defined(__AVR_ATtiny84__)
    // --- PORT and BIT for ATtiny84
    #define _PORTIN         PINB        // Port B
    #define _ARDUINO_IN     2           // DIL-5 / ArduinoPin 8
    //                        76543210
    #define _BIT_IN         0B00000100
    #define _PORTOUT        PORTA       // Port A
    #define _ARDUINO_OUT    3           // DIL-10 / ArduinoPin 3
    //                        76543210
    #define _BIT_OUT        0B00001000
    #define _MID  320
//
#elif defined(__AVR_ATtiny85__)
    // --- PORT and BIT for ATtiny85
    #define _PORTIN         PINB        // Port B
    #define _ARDUINO_IN     4           // DIL-3 / ArduinoPin 4
    //                        76543210
    #define _BIT_IN         0B00010000
    #define _PORTOUT        PORTB       // Port B
    #define _ARDUINO_OUT    1           // DIL-6 / ArduinoPin 1
    //                        76543210
    #define _BIT_OUT        0B00000001
    #define _MID  320
//
#else
    #error "Choose Arduino UNO, ATtiny84 or ATtiny85!"
#endif

uint16_t    count = 0;
uint32_t    startPulse, prevPulse, lastPulse;
uint32_t    midDuration;        // use this pulseDuration as base for the long/short test
uint32_t    midPulse;           // pulseDuration / 2
uint32_t    lastPllTimer;     // if Due, start measering the pulseWidt at firs pulse
uint32_t    wait4BitTimer;
uint32_t    debugTime;

//========================================================================================
/*  pulse @3700Hz => 270uSec
*   pulse @2400Hz => 417uSec 
*/
void tunePLL()
{
  uint32_t  startTime;
  uint32_t  startBit;
  uint32_t  pllTimer;
  uint32_t  bitCount = 0;
  uint32_t  bitDuration = 0;
  uint16_t  lowCount, highCount;
  SPrint("Waiting for first pulse ..");

  lastPllTimer = millis();

  wait4BitTimer      = millis();
  while ( ((_PORTIN & _BIT_IN) == 0) && ((millis()-wait4BitTimer) < WAIT4BIT) ); // wait for HIGH
  while ( ((_PORTIN & _BIT_IN) == 1) && ((millis()-wait4BitTimer) < WAIT4BIT) ); // wait for LOW

//      +---+   +---+   +---+   +-----+     +-----+     +-----+     +---+ 
//      |   |   |   |   |   |   |     |     |     |     |     |     |   |
//     -+   +---+   +---+   +---+     +-----+     +-----+     +-----+   +-
//       <-270-> <-270-> <-270-> <---417---> <---417---> <---417--->
//
  wait4BitTimer      = millis();
  while ( ((_PORTIN & _BIT_IN) == 0) && ((millis()-wait4BitTimer) < WAIT4BIT) ); // wait for HIGH

  if ((millis()-wait4BitTimer) >= WAIT4BIT)
  {
    SPrintln("Timeout..");
    return;
  }
  SPrintln(" GO!");

  //startTime     = micros();
  lastPulse     = _MID;
  midDuration   = _MID;
  
  wait4BitTimer = millis();
  while (((_PORTIN & _BIT_IN) == 1) && ((millis()-wait4BitTimer) < WAIT4BIT)); // wait for LOW

  bitCount      = 0;
  pllTimer      = millis();
  startBit      = micros();
  while( (millis() - pllTimer) < 2000)  // calibrate for 3 seconds
  {

    wait4BitTimer = millis();
    while (((_PORTIN & _BIT_IN) == 0) && (millis()-wait4BitTimer) < WAIT4BIT); // wait for HIGH
    if ((millis()-wait4BitTimer) >= WAIT4BIT)  return;
    
    lastPllTimer = millis();

    bitCount++;
    prevPulse   = lastPulse;
    lastPulse   = micros() - startPulse;
    startPulse  = micros();

    if ((prevPulse < midDuration) && (lastPulse > midDuration)) 
    {
      if (bitCount > 5)
      {
        midDuration = (lastPulse + prevPulse) / 2;
      }
    }
    else if ((prevPulse > midDuration) && (lastPulse < midDuration)) 
    {
      if (bitCount > 5)
      {
        midDuration = (lastPulse + prevPulse) / 2;
      }
    }
    while (((_PORTIN & _BIT_IN) == _BIT_IN) && (millis()-wait4BitTimer) < WAIT4BIT); // wait for LOW

  } // while ...
  
  SPrint("midDuration is [");
  SPrint(midDuration);
  SPrintln("]uSec");

  if (midDuration < (_MID - 50) || midDuration > (_MID + 50)) 
  {
    midDuration = _MID;
    SPrint("midDuration is [");
    SPrint(midDuration);
    SPrintln("]uSec Changed!");
  }
 
  lastPllTimer = millis();

} //  tunePLL()


//========================================================================================
void setup() 
{
#if defined(__AVR_ATmega328P__)
    Serial.begin(115200);
#endif
    SPrintln("pulse width tester");
    pinMode(_ARDUINO_IN,  INPUT);  
    pinMode(_ARDUINO_OUT, OUTPUT);  
    
    SPrint("Bit IN  "); SPrint(_ARDUINO_IN);  SPrint(" 0B"); SPrintln(_BIT_IN,  BIN);
    SPrint("Bit OUT "); SPrint(_ARDUINO_OUT); SPrint(" 0B"); SPrintln(_BIT_OUT, BIN);
  
    debugTime = millis() + 5000;

    for (uint8_t T=0; T<200; T++) 
    {
        SET(_PORTOUT, _BIT_OUT);
        delay(5);
        CLEAR(_PORTOUT, _BIT_OUT);
        delay(5);
    }
    
    lastPllTimer = millis();
    midDuration = 0;
    midPulse      = 0;
    
}   // setup()


//========================================================================================
void loop() 
{
    if ((millis() - lastPllTimer) > PLLTIME) // give it 5 seconds
    {
      midDuration = 0;  // reset midDuration
    }
    if (midDuration == 0)
    {
      tunePLL();
      lastPllTimer = millis();
    }

    wait4BitTimer = millis();
    while (((_PORTIN & _BIT_IN) == 0) && (millis()-wait4BitTimer) < WAIT4BIT); // wait for HIGH
    if ((millis()-wait4BitTimer) >= WAIT4BIT)  return;
    
    lastPllTimer = millis();

    prevPulse   = lastPulse;
    lastPulse   = micros() - startPulse;
    startPulse  = micros();

    if ((prevPulse < midDuration) && (lastPulse > midDuration)) 
    {
        CLEAR(_PORTOUT, _BIT_OUT);
        
        if (millis() > debugTime) 
        {
            SPrintln(prevPulse);
            SPrintln(lastPulse);
            SPrintln();
            debugTime = millis() + 5000;
        }
    }

    if ((prevPulse > midDuration) && (lastPulse < midDuration)) 
    {
        SET(_PORTOUT, _BIT_OUT);
    
        if (millis() > debugTime) 
        {
            SPrintln(prevPulse);
            SPrintln(lastPulse);
            SPrintln();
            debugTime = millis() + 5000;
        }
    }
    while (((_PORTIN & _BIT_IN) == _BIT_IN) && (millis()-wait4BitTimer) < WAIT4BIT); // wait for LOW

}   // loop()


/***************************************************************************
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to permit
* persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
* THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
***************************************************************************/
