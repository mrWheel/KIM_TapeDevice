/*
***************************************************************************  
**  Program  : ATtiny85PLL
**  Copyright (c) 2017 Willem Aandewiel
**
**  TERMS OF USE: MIT License. See bottom of file.                                                            
***************************************************************************  
**  
** Micro-KIM Tape Device, ATTiny85 / ESP8266
**
** The original KIM-1 uses a PLL and a comparator to implement the receive
** path of the cassette interface. These two parts have been replaced by
** this implementation which runs on a ATTiny85 microcontroller.
**
** The KIM-1 cassette format encodes each bit using two tones:
**  1) A high-frequency tone of 3623.188 Hz 
**  2) A low-frequency tone of 2415.459 Hz
** 
** Each bit is broken up into three periods, each of which is 2.484 ms long,
** during which either the low frequency or the high frequency tone is played.
**
** Every bit starts with some high frequency pulses and ends with some low 
** frequency pulses. 
** The moment of the transition between the high- and low-frequency determines
** whether it is a '1' or a '0' bit. 
**
**      <-2482ms-> <-2484ms-> <-2484ms->
**      HHHHHHHHH  HHHHHHHHH    LLLLLL              => is a '0'
**      HHHHHHHHH    LLLLLL     LLLLLL              => is a '1'
**     
**      <---- duration ------>
**      <-duration-->
**
** The KIM-1 cassette interface uses a PLL tuned to distinguish between the
** high and low frequency tone. The output of this PLL is then fed into a
** comparator to generate a logic '1' whenever the high frequency is detected,
** and a logic '0' whenever the low frequency is detected. This logic signal
** is analyzed by the KIM-1 to reconstruct the bit-stream stored on the cassette
** tape. Each bit begins with a low-high transition, and the bit value can be
** determine by the timing of the falling edge generated by the high-frequency
** to low-frequency transition within each bit.
** 
** The job of the ATTiny85 is to perform the same function of the original PLL 
** and comparator: analyze the input signal, and generate a logic '1' output 
** whenever the high frequency is detected, and a logic '0' output whenever the 
** low frequency is detected. 
** It does this by starting a timer the moment the High freguency is detected
** and stop the timer the moment the Low frequency is detected. If the duration 
** between the starting and ending is > 3.726 milli seconds, than make the 
** output-pin LOW. If it is < 3.726 millis seconds, than make the output-pin
** HIGH.
** 
** The output-pin is connected to the TAPE_IN pin of the ESP8266 which will
** combine the bits into bytes for further processing.
**   
***************************************************************************  
*/

#define _BV(bit)            (1 << (bit))
#define SET(a,b)            ((a) |= _BV(b))
#define CLEAR(a,b)          ((a) &= ~_BV(b))

// ======================================================
// determine CPY type by verbose compile (preferences)
// parm -mmcu=atxys ==> transaltes into "__AVR_ATxys__"
// Also the -D flag can have/has someting to do with it..
// https://stackoverflow.com/questions/13853109/determine-board-type-of-arduino
// ======================================================
#if defined(__AVR_ATmega328P__)
    // --- PORT and BIT for UNO
    #define _PORTIN         PIND        // Port D
    #define _ARDUINO_IN     3           // ArduinoPin 3
    //                        76543210
    #define _BIT_IN         0B00001000
    #define _PORTOUT        PORTD       // Port D
    #define _ARDUINO_OUT    7           // ArduinoPin 7
    //                        76543210
    #define _BIT_OUT        0B10000000
//
#elif defined(__AVR_ATtiny84__)
    // --- PORT and BIT for ATtiny84
    #define _PORTIN         PINB        // Port B
    #define _ARDUINO_IN     2           // DIL-5 / ArduinoPin 8
    //                        76543210
    #define _BIT_IN         0B00000100
    #define _PORTOUT        PORTA       // Port A
    #define _ARDUINO_OUT    3           // DIL-10 / ArduinoPin 3
    //                        76543210
    #define _BIT_OUT        0B00001000
//
#elif defined(__AVR_ATtiny85__)
    // --- PORT and BIT for ATtiny85
    #define _PORTIN         PINB        // Port B
    #define _ARDUINO_IN     4           // DIL-3 / ArduinoPin 4
    //                        76543210
    #define _BIT_IN         0B00010000
    #define _PORTOUT        PORTB       // Port B
    #define _ARDUINO_OUT    1           // DIL-6 / ArduinoPin 1
    //                        76543210
    #define _BIT_OUT        0B00000001
//
#else
    #error "Choose Arduino UNO, ATtiny84 or ATtiny85!"
#endif

#define _SHORT  320

uint16_t    count = 0;
uint16_t    minCount, maxCount;
uint32_t    startPulse, prevPulse, lastPulse;
uint32_t    debugTime;

void setup() {
#if defined(__AVR_ATmega328P__)
    Serial.begin(9600);
    Serial.println("pulse width tester");
#endif
    pinMode(_ARDUINO_IN,  INPUT);  
    pinMode(_ARDUINO_OUT, OUTPUT);  
    
#if defined(__AVR_ATmega328P__)
    Serial.print("Bit IN  "); Serial.print(_ARDUINO_IN);  Serial.print(" 0B"); Serial.println(_BIT_IN,  BIN);
    Serial.print("Bit OUT "); Serial.print(_ARDUINO_OUT); Serial.print(" 0B"); Serial.println(_BIT_OUT, BIN);
  
    debugTime = millis() + 5000;
#endif  
    for (uint8_t T=0; T<200; T++) {
        SET(_PORTOUT, _BIT_OUT);
        delay(5);
        CLEAR(_PORTOUT, _BIT_OUT);
        delay(5);
    }

}   // setup()

void loop() {
    while ((_PORTIN & _BIT_IN) == 0); // wait for HIGH
    prevPulse   = lastPulse;
    lastPulse   = micros() - startPulse;
    startPulse  = micros();
    if ((prevPulse < _SHORT) && (lastPulse > _SHORT)) {
        CLEAR(_PORTOUT, _BIT_OUT);
    }
    if ((prevPulse > _SHORT) && (lastPulse < _SHORT)) {
        SET(_PORTOUT, _BIT_OUT);

#if defined(__AVR_ATmega328P__)
        if (millis() > debugTime) {
            Serial.println(prevPulse);
            Serial.println(lastPulse);
            Serial.println();
            debugTime = millis() + 5000;
        }
#endif
    }
    while ((_PORTIN & _BIT_IN) == _BIT_IN); // wait for LOW

}   // loop()


/***************************************************************************
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to permit
* persons to whom the Software is furnished to do so, subject to the
* following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
* THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
***************************************************************************/

